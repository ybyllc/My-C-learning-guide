//指针的意思不是鼠标的那个指针23333
//指针就是指向变量和对象的地址(在内存里)
//指针就是这个变量在电脑里的编号，无论哪个数在电脑里都是有一个编号
//比如i = 1234，地址可能是0001
//j = 2000，地址可能是0002

//指针概念总结：
//int *x  定义指针变量
//*x  指向这个地址的值
//&a  这个值的地址 
//指针变量的类型和要指向的变量的类型一致

//数组名就是这个数组的首地址 a=&a[0]
//应用：比如*a=a[0]，*(a+1)=a[1]



/* 以下内容来自知乎回答
为什么有人讨厌指针？ - 编程指北的回答 - 知乎
https://www.zhihu.com/question/432288840/answer/1798182117

指针很简单，说白了就跟快递柜似的：
大家都用过吧，丰巢或者超市储物柜都是这样，每个格子都有一个编号，我们只需要拿到编号，然后就能找到对应的格子，取出里面的东西。
这里的格子就是内存单元，编号就是地址，格子里放的东西就对应存储在内存中的内容。
是的，这篇回答的主题是「指针与内存模型」
说到指针，就不可能脱离开内存，学会指针的人分为两种，一种是不了解内存模型，另外一种则是了解。
不了解的对指针的理解就停留在“指针就是变量的地址”这句话，会比较害怕使用指针，特别是各种高级操作。
而了解内存模型的则可以把指针用得炉火纯青，各种 byte 随意操作，让人直呼 666。


计算机的内存是一块用于存储数据的空间，由一系列连续的存储单元组成
由于 1 个 bit 只能表示两个状态，所以大佬们规定 8个 bit 为一组，命名为 byte。
并且将 byte 作为内存寻址的最小单元，也就是给每个 byte 一个编号，这个编号就叫内存的地址。

这就相当于，我们给小区里的每个单元、每个住户都分配一个门牌号： 301、302、403、404、501......
在生活中，我们需要保证门牌号唯一，这样就能通过门牌号很精准的定位到一家人。
同样，在计算机中，我们也要保证给每一个 byte 的编号都是唯一的，这样才能够保证每个编号都能访问到唯一确定的 byte。

作者：编程指北
链接：https://www.zhihu.com/question/446081991/answer/1750055743
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

有了内存，接下来我们需要考虑，int、double 这些变量是如何存储在 0、1 单元格的。在 C 语言中我们会这样定义变量：*/
int a = 999;
char c = 'c';
/*当你写下一个变量定义的时候，实际上是向内存申请了一块空间来存放你的变量。
我们都知道 int 类型占 4 个字节，并且在计算机中数字都是用补码（不了解补码的记得去百度）表示的。
999 换算成补码就是：0000 0011 1110 0111
这里有 4 个byte，所以需要四个单元格来存储

那如果我们要想知道变量到底放在哪了呢？

可以通过运算符 & 来取得变量实际的地址，这个值就是变量所占内存块的起始地址。
(PS: 实际上这个地址是虚拟地址，并不是真正物理内存上的地址

我们可以把这个地址打印出来:
printf("%x", &a);
大概会是像这样的一串数字:0x7ffcad3b8f3c

上面说，我们可以通过 & 符号获取变量的内存地址，那获取之后如何来表示这是一个 地址 ，而不是一个普通的值呢？

对，就是指针，你可以这样:

int *pa = &a; 

pa就是指向 a 的指针，里面存储的就是变量 a 的地址。

可是我还是不知道指针存在的必要性，怎么办呢

看下面代码:
int fun(...)
{
  ... 
};

int main()
{
 int a;
 fun(...);
};

假设我有一个需求： 要求在func 函数里要能够修改 main 函数里的变量 a，
这下咋整，在 main 函数里可以直接通过变量名去读写 a 所在内存。 
但是在 func 函数里是看不见a 的呀。

你说可以通过&取地址符号，将 a 的地址传递进去：
int func(int address) {
  ....
};

int main() {
 int a;
 func(&a);
};
这样在func 里就能获取到 a 的地址，进行读写了。
理论上这是完全没有问题的，但是问题在于:编译器该如何区分一个 int 里你存的到底是 int 类型的值，还是另外一个变量的地址（即指针）。这如果完全靠我们编程人员去人脑记忆了，会引入复杂性，并且无法通过编译器检测一些语法错误。而通过int * 去定义一个指针变量，会非常明确：这就是另外一个 int 型变量的地址。编译器也可以通过类型检查来排除一些编译错误。这就是指针存在的必要性。实际上任何语言都有这个需求，只不过很多语言为了安全性，给指针戴上了一层枷锁，将指针包装成了引用。


*/

自带的输入法按ctrl+。可以一直用英文标点







//定义指针变量
int/char/float/double* x;//*就表示指针变量
//指针变量初始化
int x=8
int* px=&x;
//&是取地址运算符，就是变量在内存中的地址

绕的地方在于，*这个符号在定义的时候代表指针，在用的时候又代表指针的解释器
所以int *add=&fun;
        *add=fun

其实int* add=&fun;
        *add=fun;这样写就通了        

假设有个包在23号柜子里
x=bag,*地址=&x
地址就是包的地址
*地址就是包

//每个变量的值在电脑的内存中都有一个地址。比如a=0，a的地址&a是1
//然后有个指针变量就是用来存这个地址。pa就是1
//它自己也有一个地址。&pa是3
//然后取pa的地址的数，*pa就是取1的地方的数，*pa就是a的值，就是0
//（套娃，就硬套）

//可以试试他们分别输出的值
int a = 0
int* pa=&a;
printf("a=%d,&a=%d,pa=%d,&pa=%d,*pa=%d",a,&a,pa,&pa,*pa);
//我的结果是a=0,&a=6422308,pa=6422308,&pa=6422304,*pa=0
//a，&a a的地址，pa a的地址，&pa pa的地址，*pa 地址的内容。
//可以看到，&a就是pa，*pa就是a

//或者
int x=3;
int* y=&x;
printf("%d",*y);
//输出3
printf("%d",y);
//输出x的地址

//指针的作用
//指针使程序的不同部分能够共享数据,如果将某一个数据值的地址从一个函数传递到另外一个函数，这两个函数就能使用同一数据。

//指针可以用来记录数据项之间的关系   
//在高级程序设计应用中，指针被广泛应用于构造单个数据值之间的联系。比如，程序员通常在第一个数据的内部表示中包含指向下一个数据项的指针（实际上就是链表了），来说明这两个数据项之间有概念上的顺序关系。
//指针的使用使得不同区域的代码可以轻易的共享内存数据。当然小伙伴们也可以通过数据的复制达到相同的效果，但是这样往往效率不太好。因为诸如结构体等大型数据，占用的字节数多，复制很消耗性能。
//但使用指针就可以很好的避免这个问题，因为任何类型的指针占用的字节数都是一样的（根据平台不同，有4字节或者8字节或者其他可能）。
//还有在很多时候变量，特别是对象的数据量实在太大，程序员就会用指针来做形参，只需要传递一个地址就行，大大提高了效率。
//
## 其他
* 指针使得一些复杂的链接性的数据结构的构建成为可能，比如链表，链式二叉树等等。

* 第三，有些操作必须使用指针。如操作申请的堆内存。还有：C语言中的一切函数调用中*，值传递都是“按值传递”的。如果要在函数中修改被传递过来的对象，就必须通过这个对象的指针来完成。