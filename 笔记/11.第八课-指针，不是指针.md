指针的意思不是鼠标的那个指针23333\
它就是指向内存里的一个位置（地址path）\
也就是变量的地址

指针就是地址,位置

如果指针是0级,变量是1级
那*就是升级,&就是降级

值    a   *p      
               结果:a == *p
地址  &a → p

以下内容来自知乎回答\
[为什么有人讨厌指针？ - 编程指北的回答 - 知乎](https://www.zhihu.com/question/432288840/answer/1798182117)

指针很简单，说白了就跟快递柜似的：
大家都用过吧，丰巢或者超市储物柜都是这样，每个格子都有一个编号，我们只需要拿到编号，然后就能找到对应的格子，取出里面的东西。
这里的格子就是内存单元，编号就是地址，格子里放的东西就对应存储在内存中的内容。
是的，这篇回答的主题是「指针与内存模型」
说到指针，就不可能脱离开内存，学会指针的人分为两种，一种是不了解内存模型，另外一种则是了解。
不了解的对指针的理解就停留在“指针就是变量的地址”这句话，会比较害怕使用指针，特别是各种高级操作。
而了解内存模型的则可以把指针用得炉火纯青，各种 byte 随意操作，让人直呼 666。

知道这个变量的编号在哪，就可以直接上门修改他


计算机的内存是一块用于存储数据的空间，由一系列连续的存储单元组成
由于 1 个 bit 只能表示两个状态，所以大佬们规定 8个 bit 为一组，命名为 byte。
并且将 byte 作为内存寻址的最小单元，也就是给每个 byte 一个编号，这个编号就叫内存的地址。

这就相当于，我们给小区里的每个单元、每个住户都分配一个门牌号： 301、302、403、404、501......
在生活中，我们需要保证门牌号唯一，这样就能通过门牌号很精准的定位到一家人。
同样，在计算机中，我们也要保证给每一个 byte 的编号都是唯一的，这样才能够保证每个编号都能访问到唯一确定的 byte。


有了内存，接下来我们需要考虑，int、double 这些变量是如何存储在 0、1 单元格的。在 C 语言中我们会这样定义变量：*/
int a = 999;
char c = 'c';
/*当你写下一个变量定义的时候，实际上是向内存申请了一块空间来存放你的变量。
我们都知道 int 类型占 4 个字节，并且在计算机中数字都是用补码（不了解补码的记得去百度）表示的。
999 换算成补码就是：0000 0011 1110 0111
这里有 4 个byte，所以需要四个单元格来存储

那如果我们要想知道变量到底放在哪了呢？

可以通过运算符 & 来取得变量实际的地址，这个值就是变量所占内存块的起始地址。
(PS: 实际上这个地址是虚拟地址，并不是真正物理内存上的地址

我们可以把这个地址打印出来:
printf("%x", &a);
大概会是像这样的一串数字:0x7ffcad3b8f3c

上面说，我们可以通过 & 符号获取变量的内存地址，那获取之后如何来表示这是一个 地址 ，而不是一个普通的值呢？

对，就是指针，你可以这样:

int *pa = &a; 

pa就是指向 a 的指针，里面存储的就是变量 a 的地址。

可是我还是不知道指针存在的必要性，怎么办呢

看下面代码:
int fun(...)
{
  ... 
};

int main()
{
 int a;
 fun(...);
};

假设我有一个需求： 要求在func 函数里要能够修改 main 函数里的变量 a，
这下咋整，在 main 函数里可以直接通过变量名去读写 a 所在内存。 
但是在 func 函数里是看不见a 的呀。

你说可以通过&取地址符号，将 a 的地址传递进去：
int func(int address) {
  ....
};

int main() {
 int a;
 func(&a);
};
这样在func 里就能获取到 a 的地址，进行读写了。
理论上这是完全没有问题的，但是问题在于:

编译器该如何区分一个 int 里你存的到底是 int 类型的值，还是另外一个变量的地址（即指针）。

这如果完全靠我们编程人员去人脑记忆了，会引入复杂性，并且无法通过编译器检测一些语法错误。

而通过int * 去定义一个指针变量，会非常明确：这就是另外一个 int 型变量的地址。

编译器也可以通过类型检查来排除一些编译错误。

这就是指针存在的必要性。

实际上任何语言都有这个需求，只不过很多语言为了安全性，给指针戴上了一层枷锁，将指针包装成了引用。

pa中存储的是a变量的内存地址，那如何通过地址去获取a的值呢？

这个操作就叫做解引用，在 C 语言中通过运算符 *就可以拿到一个指针所指地址的内容了。

比如*pa就能获得a的值。

*/


自带的输入法按ctrl+。可以一直用英文标点







//定义指针变量
int/char/float/double *x;//*就表示指针变量
//指针变量初始化
int x=8,*px=&x;
//&是取地址运算符，就是变量在内存中的地址

//每个变量的值在电脑的内存中都有一个地址。比如a=0，a的地址&a是1
//然后有个指针变量就是用来存这个地址。pa就是1
//它自己也有一个地址。&pa是3
//然后取pa的地址的数，*pa就是取1的地方的数，*pa就是a的值，就是0
//（套娃，就硬套）

//可以试试他们分别输出的值
int a = 0,*pa=&a;
printf("a=%d,&a=%d,pa=%d,&pa=%d,*pa=%d",a,&a,pa,&pa,*pa);
//我的结果是a=0,&a=6422308,pa=6422308,&pa=6422304,*pa=0
//可以看到，&a就是pa，*pa就是a

//或者
int x=3;
int *y=&x;
printf("%d",*y);
//输出100
printf("%d",y);
//输出x的地址

